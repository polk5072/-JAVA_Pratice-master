       /*
        기본적인 변수 선언

        int n = 15;     // 십진수 15
        int m = 015;    // 8진수 13
        int k = 0x15;   // 16진수 21
        int l = 0b0101; // 2진수 5

        long lk = 150l;
        String kor = null; // String 은 객체이므로 null이 할당가능하다.

        */


        /* 조건 연산자
        * 조건 연산자는 3개의 피연산자로 구성되어 삼항 연산자라고도 한다.
        * 형식 *

         condition ? opr2 : opr3





        int x = 5;
        int y = 3;
        int s = (x>y) ? 1:-2; // x > y 이므로 1이 s에 할당된다

        System.out.println(s); // 1이 출력됨
        */

        /* 비트 연산
        컴퓨터는 모든 정보를 0과 1값만 가지는 2진수로 저장한다.

        여기서 2진수의 한 자리를 비트 bit 라고 부르며, 8 비트를 1byte라고 한다.

        십진수 10을 한 바이트로 표현하면 00001010이다.
        */

        /*  byte flag; //byte의 8개의 각 비트는 8개의 센서 값을 각각 가리킨다.

        if(flag & 0b00001000 ==0) System.out.println("온도는 0도 이하");
        else System.out.println("온도는 0도 이상"); */

        /* 비트 시프트 연산
        byte a = 5; //0b00000101 로 저장됨
        byte b = (byte) (a << 2); // a 값을 왼쪽으로 2비트만큼 이동.
        // 즉 0b00000101 > 0b00010100
        // >> 와 <<는 1비트씩 시프트 할 때마다 나누기2 / 곱하기 2의 효과가 각각 나타난다.

        // 논리적 오른쪽 시프트
        byte x = 20; // 20 할당
        byte y = (byte)(x >>> 2);

        System.out.println(b); // 20이 출력됨
        System.out.println(y); // 0b00010100 -> 0b00000101  => 5

        //산술적 오른쪽 시프트
        byte k = (byte) 0xf8; // 1111 1000

        // 2의 보수 표현법 공부하기

         */

        // 배열 //
        /* 배열은 인덱스와 인덱스에 대응하는 데이터들로 이루어진 연속적인 자료 구조로서, 같은 종류의 데이터들이 순차적으로 저장된다.

        선언하는 형식은 아래와 같다.

        int i [] = new int[10];

        세부적으로 살펴보면 자바에서 배열의 생성은 두 단계로 이루어진다.
        1. 배열에 대한 레퍼런스 변수 선언
        2. 배열 생성 - 배열의 저장 공간 할당

        1 -> int intArray [];에서
        int 배열의 타입 지정
        intArray 배열에 대한 레퍼런스 변수 지정
        [] 배열 선언을 의미한다.

        2-> intArray = new int [5];에서
        intArray 배열에 대한 레퍼런스 변수
        new 배열 생성
        int 타입
        [5] 원소 갯수를 의미한다. */

        /*   다차원 배열

        자바에서는 여러 차월의 배열을 만들 수 있다.

        3차원 이상의 배열은 특별한 경우에만 사용한다.

        자바의 배열은 C/C++ 과는 다른 독특한 구조를 가진다.


        * 2차원 배열 *

        1. 선언과 생성

        1차월 배열과 마찬가지로 2차원 배열에서도 레퍼런스 변수 선언 후 배열을 생성한다.

        int intArray [][];
        char charArray [][];

        int [][] intArray;
        char [][] charArray;

        위와 같이 2가지 방법으로 2차원 배열을 생성할 수 있다.

        -- 저장공간 생성 --

        int [][] intArray = new int [2][5]; -> 2 x 5 의 배열 구조를 갖는다.
        [2] -> 행을 의미 [5] -> 열을 의미한다.

        위와 같이 저장공간을 생성하는 것은 1차원 배열과 크게 다르지 않음을 볼 수 있다.

        배열에서의 length 의미를 알아보자

        int [][] intArray = new int [2][5] ; => 해당 코드와 같이 선언과 동시에 생성도 가능

        intArray.length -> 2
        intArray[0].length -> 5
        intArray[1].length -> 5

        -- 2차원 배열의 초기화 --

        아래와 같이 2차원 배열을 선언할 때 각 원소를 초기화 할 수 있다.
        그러면 자동으로 원소 개수만한 배열 공간이 할당되고, 원소 값으로 초기화한다.

        int intArray[][] = { {0,1,2} , {3,4,5} , {6,7,8} };  //  3 x 3의 배열이 생성됨
        char [][] charArray = { {'a','b', 'c'}, {'d','e','f'} } // 2 x 3의 배열이 생성됨

        -- 비정방형 배열 --

        정방형 배열은 행과 열의 갯수가 같은 모두 동일한 배열이다.

        이와 반대로 비정방형 배열은 행마다 열의 개수가 서로 다른 배열을 말한다.

        ex)
        int [][] intArray = new int [4][];

        intArray[0] = new int[3];
        intArray[1] = new int[4];
        intArray[2] = new int[1];  ...

        위와 같이 비정방형 배열이 생성 가능하다.

        -- 메소드에서의 배열 리턴 --

        먼저 메소드에서는 어떤 배열이든지 리턴하면 배열에 대한 레퍼런스만 리턴된다.



       -- main() 메소드 --

       main 메소드는 자바 응용프로그램의 실행이 시작되는 특별한 메소드로 원형은 아래와 같다.

       public static void main(String[] args){}

       public -> 다른 클래스에서 메소드 접근 허용

       * 자바 응용프로그램이 시작할 때 자바 가상 기계(JVM)에 의해 호출되어야 하므로 public 속성으로 선언되어야 한다.

       static -> 객체 생성 전부터 호출이 가능

       * 자신을 포함하는 클래스의 객체가 생성되기 전에, 처음부터 자바 가상 기계에 의해 호출이 되므로 static 속성이 선언되어야 한다.

       void -> 리턴 값 없음

       * 아무 값도 리턴하지 않기 때문에 void 타입이다. main() 메소드를 끝내기 위해 리턴하려면 return ; 하면 된다.

       String[] args 문자열 배열을 매개변수로 받음

       * 자바는 명령행에 입력된 인자들을 문자열 배열로 만들어 main() 메소드에 전달한다.

       -- main() 메소드의 매개변수 --

       자바에서 main() 메소드의 매개변수에 어떤 값이 어떻게 전달되는 지 알아보자.

       다음은 Hello 클래스를 실행하는 명령의 사례

       C:\> java Hello option1 option2 option3 ... -> Hello 클래스의 main() 에서 실행 시작됨

       option 1 ~ option ... 까지는 명령행 인자라고 부르며 이들은 모두 Hello 클래스의 main() 메소드의 매개변수로 전달된다.

       Hello 클래스의 main() 메소드가 시작되기 전, 이 인자들은 각각 문자열로 만들어지고 문자열 배열에 저장된다.

       ex)

       C\> java Hello 3 5 7

       ->
       class Hello{

       public static void main(String[] args){ }  args를 "3","5","7" 을 받아 크기 3의 배열이 초기화되어 생성된다.

       }

       --자바의 예외 처리 --
        자바의 예외처리는 아래와 같은 상황에서 발생할 수 있다.
        * 정수를 0으로 나누는 경우
        * 배열의 크기보다 큰 인덱스로 배열의 원소를 접근하는 경우
        * 존재하지 않는 파일을 읽으려고 하는 경우
        * 정수 입력을 기다리는 코드가 실행되고 있을 때, 사용자가 문자를 입력한 경우

        사례를 보자. to. exception_practice.java 파일로

        -- 클래스와 객체 --
        Class_prctice.java 파일로 실행

        먼저 객체에 대해서 설명해야겠다.
        객체란?
        컴퓨터 과학에서 객체 또는 오브젝트는 클래스에서 정의한 것을 토대로 메모리에 할당된 것으로 프로그램에서 사용되는 데이터 또는 식별자에 의해 참조되는 공간을 의미한다.

        자바는 객체지향 언어로 객체지향의 특성을 설명한다.

        1. 캡슐화
        -> 객체를 캡슈롤 싸서 내부를 보호하고 볼 수 없게 하는 것으로 객체의 가장 본질적인 특징이다.
        자바에서 객체는 클래스라는 캡슐을 사용하며, 필드와 메소드로 구성된다.

        2. 상속
        상속은 상위 개체의 속성이 하위 개체에 물려져서, 하위 개체가 상위 개체의 속성을 모두 가지는 관계이다.

        자바에서의 상속은 자식 클래스가 부모  클래스의 속성을 무려받고 기능을 추가하여 확장하는 개념이다.
        부모 클래스를 슈퍼클래스라고 하며 자식 클래스를 서브 클래스라고 부른다.

        3. 다형성
        -> 같은 이름의 메소드가 클래스 혹은 객체에 따라 다르게 동작하도록 구현되는 것을 말한다.
        ex> Animal 이르는 슈퍼 클래스를 상속받고 소리내기 speak()라는 메소드를 각각 다르게 개 , 고양이, 닭 클래스에 구현하였다.

        이때 서브 클래스에서 동일한 이름으로 자신의 특징에 맞게 다시 구현하는 것을 '메소드 오버라이딩'이라고 한다.

        다형성의 또 다른 사례는 클래스 내에서 이름이 같지만 서로 다르게 동작하는 메소드를
        여러 개 만드는 '메소드 오버로딩'도 있다.

        -- 객체 지향의 목적 --

        1. 소프트웨어 생산성 향상
        소프트웨어의 재사용을 위한 여러 기법들을 가진 객체 지향 언어

        2. 실세계에 대한 쉬운 모델링

        클래스와 객체의 차이점
        클래스는 객체를 만들어 내기 위한 설계도 혹은 틀이며, 클래스 모양 그대로 생성된 실체가 객체이다.

        객체를 클래스의 "인트턴스" 라고도 부른다

        클래스는 크게 이렇게 구성된다.

        public class Circle{
        접근 권한 /  클래스 선언 / 클래스 이름
        필드 (변수) 영역

        메소드 영역

        public Circle(){} // Circle 메소드의 생성자
        생성자 -> 클래스의 이름과 동일한 메소드를 특별히 생성자라고 한다.
        생성자 객체가 생성될 때 자동으로 호출되는 특별한 메소드이다.

        }

        생성자는 객체가 생성될 때 객체의 초기화를 위해 실행되는 메소드이다.

        생성자는 객체가 생성되는 순간에 자동으로 호출되는 메소드로서, 객체에 필요한 초기화를 실행하는 코드를 담아야 한다.
        ex)
        public Circle(int i, String n){
        this.변수 = i; this.변수=n;
        }

        생성자 특징
        1. 생성자의 이름은 클래스 이름과 동일하다.
        2. 생성자는 여러 개 작성 즉 오버로딩 할 수 있다.
        3. 생성자는 new를 통해 객체를 생성할 때 한 번만 호출된다.
        4. 생성자에 리턴 타입을 지정할 수 없다.
        5. 생성자의 목적은 객체가 생성될 때, 필요한 초기 작업을 위함이다.

        기본생성자란 매개변수와 실행 코드가 없어 아무 일도 하지 않고 단순 리턴하는 생성자이다.
        '디폴트 생성자'라고도 부른다


        this 레퍼런스

        this는 현재 객체 자신에 대한 레퍼런스이다.
        보다 정확이 말하면 현재 실행되고 있는 메소드가 속한 객체에 대한 레퍼런스를 말한다.

       사용의 예는 Class_practice.java 파일을 참조하라.

       this는 왜 필요한가 ?

       매개변수의 이름은 그 자체로서 코드를 읽는 사람에게 그 용도를 나타내므로, 적합한 이름을 붙이는 것은 매우 중요하다.

       그래서 Circle(int r) 생성자의 매개변수를 r 대신 다음과 같이 radius 로 변경하는 것이 좋다.

       즉
       this 레퍼런스를 사용하지 않는다면
       public Circle(int radius){ radius = radius; } 의 형태로 생성자를 생성한다.

       radius = radius 와 같이 매개변수와 멤버변수가 이름이 같을때 애매한 상황이 벌어진다.

       this 레퍼런스 사용시

       public Circle(int radius){ this.radius = radius;}

       이렇게 효과적으로 명시할 수 있다 .

       또한 메소드가 객체 자신의 레퍼런스를 리턴해야 하는 경우가 있는데 이럴땐

       return this; 를 사용해 객체 자신의 래퍼런스를 리턴할 수 있다.

       this 는 생성자의 첫번째 문장이어야 한다.

        -- 객체 배열 --

        자바에서는 기본 타입 데이터뿐 아니라 객체를 원소로 하는 객체 배열도 만들 수 있다.

        자바의 객체 배열은 객체에 대한 레퍼런스를 원소로 갖는 배열이다.

        Circle [] c;
        circle = new Circle[5];

        위 처럼 만든 객체는 0 ~ 4 까지의 객체 배열을 갖는다.
        각 객체는 배열과 동일하나 한개 한개가 객체를 갖는 것을 의미한다.

        -- 메소드 활용 --

        1. 메소드의 형식
        메소드는 클래스의 멤버 함수로서 메소드 앞에 접근 지정자를 선언한다는 점을 제외하면 C / C++의 함수 작성법과 동일하다.

        접근 지정자는 public, private, protected, default 4자기 유형으로 메소드가 다른 클래스에서 호출될 수 있는지 지정하기 위해 사용한다.

        2. 인자 전달
        자바의 메소드 호출 시 인자 전달 방식은 '값에 의한 호출'이다.

        호출하는 실인자의 값이 복사되어 메소드의 매개 변수에 전달된다.


        3. 메소드 오버로딩

        자바에서는 한 클래스 내에, 이름이 같지만 매개변수의 타입이나 개수가 서로 다른 여러 개의 메소들르 중복 작성할 수 있다.

        이것을 메소드 오버로딩 혹은 메소드 중복이라고 부른다.

        메소드 오버로딩의 조건
        1) 메소드 이름이 동일하여야 한다.
        2) 매개변수의 개수나 타입이 서로 달라야 한다.


        --객체의 소멸과 가비지 컬렉션--

        1. 객체의 소멸
        -> 자바에는 객체를 생성하는 new 연산자는 있지만 객체를 소멸시키는 연산자는 없다. 그러므로 자바에서는 객체를 소멸시킬 수 없다.

        객체 소멸이란 new에 의해 생성된 객체 공간을 자바 가상 기계에서 돌려주어 가용 메모리에 포함시키는 것이다.
        다른 객체 지향 언어인 C++에는 delete 연산자를 두고 있으며, delete 연산자가 실행되면 객체가 곧 바로 소멸된다.
        그러나 자바는 delete 연산자도 소멸자도 없다.

        그렇기에 자바에서 new로 할당받은 후 사용하지 않게 된 객체 메모리는 가비지라고 부르며
        자바 가상 기계의 가비지 컬렉터가 적절한 시점에 자동으로 수집하여 가용 메모리에 반환시킨다.

        가비지란
        자바 응용프로그램에서 더 이상 사용되지 않게 된 객체나 배열 메모리이다.

        가비지 컬렉션
        가비자가 많아지면 자바 플랫폼이 응용프로그램에게 할당해줄 수 있는 가용메모리 양이 줄어들게 된다.
        시간이 지날수록 자연히 가비지가 늘어나게 되며, 최악의 경우 자바 플랫폼의 가용 메모리가 0이 되면 자바 응용프로그램은 더 이상 실행될 수 없다.

        이런 경우를 대비하여 자바 플랫폼은 가용 메모리가 일정 크기 이하로 줄어들면 자동으로 가비지를 회수하여 가용 메모리를 늘린다.

        이것을 '가비지 컬렉션' 이라고 부른다.

        규모가 큰 자바 프로그램은 실행 중 비교적 많은 양의 가비지를 생산한다.
        그러다가 가끔 가용 메모리가 부족해지는 경우가 있는데, 이때 가비지 컬렉터가 실행되며 응용 프로그램은 실행을 멈추고 가비지 컬렉션이
        끝나기를 기다리게 되어, 사용자의 눈에는 프로그램이 중단된 것처럼 보인다. 이런 이유로 자바는 실시간 처리 응용에는 부적합한 것으로 알려져 있다.

        가비지 컬렉션 강제 요청
        응용프로그램에서 System 또는 Runtime 객체의 gc() 메소드를 호출하면 가비지 컬렉션을 요청한다.

        System.gc();

        위 명령어가 있더라도 자바 플랫폼이 전적으로 판단하여 적절한 시점에 작동시킨다.

        -- 접근 지정자 --

        1. 패키지
        자바는 서로 관연 있는 클래스 파일들을 패키지에 저장하여 관리하도록 한다.
        디렉터리와 같은 개념이며, 개발자는 클래스 파일들을 여러 패키지에 분산 관리하는 것이 일반적이다.

        2. 접근 지정자
        접근 지정자는 클래스나 멤버들을 다른 클래스에서 접근해도 되는지의 여부를 선언하는 지시어이다.

        1) public 클래스
        public으로 선언된 클래스로서, 패키지에 상관없이 다른 어떤 클래스에서도 사용이 허용된다.

        2) default 클래스
        접근 지정자 없이 클래스를 선언한 경우 디폴트 접근 지정으로 선언되었다고 한다.
        디폴트 클래스는 같은 패키지 내의 클래스들에게만 사용이 허용된다.

        3) private 클래스
        private 클래스는 같은 클래스 내의 멤버들에게만 접근이 허용된다.

        4) protected 클래스
        protected 클래스는 보호된 공개를 지시하는 것으로, 같은 패키지 / 자식 클래스 의 경우에만 사용을 허용한다.

        -- non-static / static 멤버 --
        static 멤버는 객체를 생성하지 않고도 사용할 수 있는 멤버이다.

        static 멤버는 클래스당 하나만 생성되는 멤버로서 동일한 클래스의 모든 객체들이 공유한다.
        그리고 main() 메소드가 실행되기 전에 이미 생성된다. static 멤버는 static 멤버가 포함된 객체를 생성하기 전에도 사용할 수 있다.

        반면 non-static 멤버는 객체가 생길 때 객체마다 생기며, 다른 객체들과 공유하지 않는다.
        객체가 사라지면 non-static 멤버도 함께 사라지고 더 이상 접근할 수 없다.

        static 메버는 클래스당 하나씩 생긴다고 해서 클래스 멤버라고도 부르며
        non-static 멤버는 각 객체마다 하나씩 생긴다고 해서 인스턴스 멤버라고 부른다.

        -- static 멤버의 생성 --
        static 멤버가 생성되는 시점은 StaticSample이사용되기 시작하는 시점이다.
        아래 코드가 실행되는 시점에는 static 멤버 m과 f()는 이미 존재하며 사용이 가능하다.

        StaticSample s1, s2;

        s1 = new StaticSample();
        s2 = new StaticSample();

        static 멤버 m과 f()는 이들 두 객체가 생성되기 이전에 이미 생성되어 있으므로, s1과 s2 객체가 생성될 때, 인스턴스 멤버인
        n,g(),h()만 객체마다 생성된다.

        static 멤버의 접근은 non-static 멤버와 사용방법이 동일하다

        객체.static필드
        객체.static메소드

        다음코드는 s1, s2 객체의 static 멤버를 접근한다.
        s1.m = 50;
        s2.f();

        --static의 활용--

        1.전역변수와 전역함수를 만들때 활용한다.
        자바에서는 어떤 변수나 함수도 클래스 바깥에 존재할 수 없으며 클래스의 멤버로 존재하여야 한다.
        이는 자바의 캡슐화 원칙 때문이다. 한편, 응용프로그램 작성 시 모든 클래스에서 공유하는 전역 변수나 모든 클래스에서
        호출할 수 있는 전역 함수가 필요한 경우가 있다.
        static은 이런 문제에 대한 해결책이다.

        static 멤버를 가진 대표적인 클래스로 java.lang.Math 클래스가 있다.

        이 클래스는 다음과 같이 객체를 생성하지 않고 바로 호출할 수 있는 static 타입의 멤버를 제공한다.

        응용프로그램에서 생성자가 private로 되어있는 경우 객체로 생성이 되지 않는다.

        오류 ex)
        Math m = new Math(); // 오류! 생성자가 private로 설정되어 있기 때문

        올바른 사용은
        int n = Math.abs(-5);

        static 메소드의 제약조건
        1. static 메소드는 static 멤버만 접근할 수 있다.
        2. static 메소드는 this를 사용할 수 없다.

        -- final 의 사용 --
        1. final 클래스는 상속받을 수 없음을 지정한다.
        2. final로 메소드를 선언하면 오버라이딩 할 수 없는 메소드임을 선언한다.
        3. final 필드를 선언하면 필드는 상수가 된다.(변경 불가능)












